name: Build libtcc (shared) - windows / linux / alpine / msvc

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  TCC_REPO: https://github.com/TinyCC/tinycc.git
  TCC_REF: mob

jobs:
  build-windows:
    name: Build on Windows (MinGW)
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up MSYS2 (MINGW64)
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-binutils
            make
            git
            autoconf
            automake
            bison
            flex

      - name: Clone tinycc (MSYS2 shell)
        shell: msys2 {0}
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Windows, MSYS2/MinGW)
        shell: msys2 {0}
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -e
          cd tinycc

          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          if make -n libtcc.dll 2>/dev/null; then
            make -j"$(getconf _NPROCESSORS_ONLN)" libtcc.dll
          else
            make -j"$(getconf _NPROCESSORS_ONLN)" || true
          fi

          mkdir -p "${GITHUB_WORKSPACE}/include"
          mkdir -p "${GITHUB_WORKSPACE}/lib"

          if [ -d include ]; then
            cp -r include/* "${GITHUB_WORKSPACE}/include/" || true
          elif [ -d tinycc/include ]; then
            cp -r tinycc/include/* "${GITHUB_WORKSPACE}/include/" || true
          fi

          DLL_PATH="$(find . -type f -name 'libtcc*.dll' -print -quit || true)"
          A_PATH="$(find . -type f -name 'libtcc*.a' -print -quit || true)"

          if [ -n "$DLL_PATH" ]; then
            cp -v "$DLL_PATH" "${GITHUB_WORKSPACE}/libtcc.dll" || true
          fi

          if [ -n "$A_PATH" ]; then
            cp -v "$A_PATH" "${GITHUB_WORKSPACE}/lib/" || true
            # provide exact filename requested
            cp -v "$A_PATH" "${GITHUB_WORKSPACE}/libtcc.lib" || true
          fi

          if [ -d lib ]; then
            find lib -type f ! -name '*.dll' -exec cp -v {} "${GITHUB_WORKSPACE}/lib/" \; || true
          fi

          mkdir -p "${GITHUB_WORKSPACE}/include"
          mkdir -p "${GITHUB_WORKSPACE}/lib"
          ls -la "${GITHUB_WORKSPACE}" || true
          ls -la "${GITHUB_WORKSPACE}/lib" || true
          ls -la "${GITHUB_WORKSPACE}/include" || true

      - name: Upload Windows artifact (MinGW)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-windows-mingw
          path: |
            libtcc.dll
            libtcc.lib
            include/
            lib/

  build-windows-msvc:
    name: Build on Windows (MSVC) - canonical .lib
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install CMake (choco) - optional for cmake path fallback
        # CMake is usually available on windows-latest images; installing is cheap and ensures availability
        run: |
          choco install -y cmake --installargs '"ADD_CMAKE_TO_PATH=System"' || true
        shell: cmd

      - name: Find Visual Studio & set up environment
        id: vsenv
        run: |
          REM find the latest VS installation using vswhere
          setlocal enabledelayedexpansion
          set VSWHERE="%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
          if not exist %VSWHERE% (
            echo "vswhere not found at %VSWHERE%, trying default path"
            REM vswhere should exist on hosted runners; if not, fail early
            dir "%ProgramFiles(x86)%\Microsoft Visual Studio\Installer" || true
          )
          for /f "usebackq tokens=*" %%i in (`%VSWHERE% -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do (
            set INSTALLPATH=%%i
          )
          if "%INSTALLPATH%"=="" (
            echo "Could not locate Visual Studio installation with VC tools; failing"
            exit /b 1
          )
          echo "VS INSTALL PATH: %INSTALLPATH%"
          set VCVARS="%INSTALLPATH%\VC\Auxiliary\Build\vcvarsall.bat"
          if not exist %VCVARS% (
            echo "vcvarsall.bat not found at %VCVARS%; failing"
            exit /b 1
          )
          echo "::set-output name=vcvars::%VCVARS%"
        shell: cmd

      - name: Build with MSVC environment (try makefile.msc / cmake / msbuild)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          @echo off
          setlocal enabledelayedexpansion

          REM get vcvars path from previous step (GitHub actions sets it as output)
          set VCVARS=%{{
            steps.vsenv.outputs.vcvars
          }}%

          if "%VCVARS%"=="" (
            REM fallback common path
            set VCVARS="C:\Program Files (x86)\Microsoft Visual Studio\2022\Professional\VC\Auxiliary\Build\vcvarsall.bat"
          )

          echo Using vcvars: %VCVARS%
          if not exist %VCVARS% (
            echo vcvarsall not found at %VCVARS% - listing VS installs for debug
            dir "C:\Program Files (x86)\Microsoft Visual Studio\2022" || true
          )

          REM prepare directories
          mkdir "%GITHUB_WORKSPACE%\include" 2>nul || true
          mkdir "%GITHUB_WORKSPACE%\lib" 2>nul || true

          REM clone done by checkout step; enter repo dir
          cd %GITHUB_WORKSPACE%
          if exist tinycc (
            cd tinycc
          ) else (
            echo "tinycc directory not found at %GITHUB_WORKSPACE%\tinycc - listing workspace"
            dir "%GITHUB_WORKSPACE%" || true
            exit /b 1
          )

          REM ensure headers get copied from include later
          REM try 1: nmake -f makefile.msc (common MSVC makefile)
          call %VCVARS% x64
          if exist makefile.msc (
            echo "Found makefile.msc, attempting: nmake -f makefile.msc"
            nmake -f makefile.msc || set BUILD_FAILED_1=1
          ) else (
            echo "makefile.msc not present"
            set BUILD_FAILED_1=1
          )

          REM if failed, try cmake -> NMake Makefiles
          if defined BUILD_FAILED_1 (
            echo "makefile.msc build failed or not present, trying CMake (NMake generator)"
            REM create out-of-source build
            if not exist build mkdir build
            cd build
            cmake -G "NMake Makefiles" -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON .. || set BUILD_FAILED_2=1
            if not defined BUILD_FAILED_2 (
              nmake || set BUILD_FAILED_2=1
            )
            cd ..
          fi

          REM if cmake failed, try to find solution or sln and build with msbuild (last resort)
          if defined BUILD_FAILED_2 (
            echo "CMake/NMake failed or not available; searching for .sln"
            for /r %%f in (*.sln) do (
              echo "Found solution: %%f"
              msbuild "%%f" /p:Configuration=Release /m || set BUILD_FAILED_3=1
              if not defined BUILD_FAILED_3 goto :after_build
            )
            set BUILD_FAILED_3=1
          )

          :after_build
          REM At this point either build succeeded or all attempts failed. Proceed to collect artifacts anyway.

          REM copy headers
          if exist include (
            xcopy /E /I /Y include "%GITHUB_WORKSPACE%\include\" || true
          )

          REM If repo has a lib folder with helper objects, copy them (exclude .dll/.so)
          if exist lib (
            for /R lib %%f in (*) do (
              if /I "%%~xf"==".dll" (
                rem skip
              ) else (
                copy /Y "%%f" "%GITHUB_WORKSPACE%\lib\" >nul 2>nul || true
              )
            )
          )

          REM Search for produced DLL and LIB files in build output and copy them to workspace root with exact names
          REM common locations: build/Release, build/bin/Release, Release\, bin\Release
          set FOUND_DLL=
          set FOUND_LIB=

          for /f "delims=" %%D in ('where /R . libtcc.dll 2^>nul') do (
            set FOUND_DLL=%%~fD
            goto :copy_dll
          )
          REM search for any dll that looks like libtcc*
          for /f "delims=" %%D in ('dir /s /b libtcc*.dll 2^>nul') do (
            set FOUND_DLL=%%~fD
            goto :copy_dll
          )
          :copy_dll
          if defined FOUND_DLL (
            echo "Copying DLL from %FOUND_DLL% to %GITHUB_WORKSPACE%\libtcc.dll"
            copy /Y "%FOUND_DLL%" "%GITHUB_WORKSPACE%\libtcc.dll" || true
            copy /Y "%FOUND_DLL%" "%GITHUB_WORKSPACE%\lib\libtcc.dll" || true
          ) else (
            echo "No libtcc.dll found by search."
          )

          REM find import .lib (MSVC .lib)
          for /f "delims=" %%L in ('where /R . libtcc.lib 2^>nul') do (
            set FOUND_LIB=%%~fL
            goto :copy_lib
          )
          for /f "delims=" %%L in ('dir /s /b libtcc*.lib 2^>nul') do (
            set FOUND_LIB=%%~fL
            goto :copy_lib
          )
          :copy_lib
          if defined FOUND_LIB (
            echo "Copying LIB from %FOUND_LIB% to %GITHUB_WORKSPACE%\libtcc.lib"
            copy /Y "%FOUND_LIB%" "%GITHUB_WORKSPACE%\libtcc.lib" || true
            copy /Y "%FOUND_LIB%" "%GITHUB_WORKSPACE%\lib\libtcc.lib" || true
          ) else (
            echo "No libtcc.lib found by search."
          )

          REM Ensure include and lib directories exist
          if not exist "%GITHUB_WORKSPACE%\include" mkdir "%GITHUB_WORKSPACE%\include"
          if not exist "%GITHUB_WORKSPACE%\lib" mkdir "%GITHUB_WORKSPACE%\lib"

          dir "%GITHUB_WORKSPACE%" || true
          dir "%GITHUB_WORKSPACE%\lib" || true
          dir "%GITHUB_WORKSPACE%\include" || true

        shell: cmd

      - name: Upload Windows artifact (MSVC)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-windows-msvc
          path: |
            libtcc.dll
            libtcc.lib
            include/
            lib/

  build-linux:
    name: Build on Linux
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install build deps (Ubuntu)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y build-essential git autoconf automake bison flex pkg-config python3 curl

      - name: Clone tinycc
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Linux)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -e
          cd tinycc
          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          if make -n libtcc.so 2>/dev/null; then
            make -j"$(getconf _NPROCESSORS_ONLN)" libtcc.so
          else
            make -j"$(getconf _NPROCESSORS_ONLN)" || true
          fi

          mkdir -p "${GITHUB_WORKSPACE}/include"
          mkdir -p "${GITHUB_WORKSPACE}/lib"

          if [ -d include ]; then
            cp -r include/* "${GITHUB_WORKSPACE}/include/" || true
          fi

          SO="$(find . -type f -name 'libtcc*.so*' -print -quit || true)"
          if [ -n "$SO" ]; then
            cp -v "$SO" "${GITHUB_WORKSPACE}/libtcc.so" || true
          fi

          if [ -d lib ]; then
            find lib -type f ! -name 'libtcc*.so*' -exec cp -v {} "${GITHUB_WORKSPACE}/lib/" \; || true
          fi

          A="$(find . -type f -name 'libtcc*.a' -print -quit || true)"
          if [ -n "$A" ]; then
            cp -v "$A" "${GITHUB_WORKSPACE}/lib/" || true
          fi

          ls -la "${GITHUB_WORKSPACE}" || true
          ls -la "${GITHUB_WORKSPACE}/lib" || true
          ls -la "${GITHUB_WORKSPACE}/include" || true

      - name: Upload Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-linux
          path: |
            libtcc.so
            include/
            lib/

  build-alpine:
    name: Build on Alpine Linux
    runs-on: ubuntu-latest
    container:
      image: alpine:3.20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install build deps (Alpine)
        run: |
          apk update
          apk add --no-cache build-base git autoconf automake bison flex pkgconfig bash linux-headers

      - name: Clone tinycc
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Alpine)
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -e
          cd tinycc
          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          if make -n libtcc.so 2>/dev/null; then
            make -j"$(getconf _NPROCESSORS_ONLN)" libtcc.so
          else
            make -j"$(getconf _NPROCESSORS_ONLN)" || true
          fi

          mkdir -p "${GITHUB_WORKSPACE}/include"
          mkdir -p "${GITHUB_WORKSPACE}/lib"

          if [ -d include ]; then
            cp -r include/* "${GITHUB_WORKSPACE}/include/" || true
          fi

          SO="$(find . -type f -name 'libtcc*.so*' -print -quit || true)"
          if [ -n "$SO" ]; then
            cp -v "$SO" "${GITHUB_WORKSPACE}/libtcc.so" || true
          fi

          if [ -d lib ]; then
            find lib -type f ! -name 'libtcc*.so*' -exec cp -v {} "${GITHUB_WORKSPACE}/lib/" \; || true
          fi

          A="$(find . -type f -name 'libtcc*.a' -print -quit || true)"
          if [ -n "$A" ]; then
            cp -v "$A" "${GITHUB_WORKSPACE}/lib/" || true
          fi

          ls -la "${GITHUB_WORKSPACE}" || true
          ls -la "${GITHUB_WORKSPACE}/lib" || true
          ls -la "${GITHUB_WORKSPACE}/include" || true

      - name: Upload Alpine artifact
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-alpine
          path: |
            libtcc.so
            include/
            lib/