name: Build libtcc (shared) - windows / linux / alpine

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  # Change this if you want a different mirror/fork
  TCC_REPO: https://github.com/TinyCC/tinycc.git
  TCC_REF: mob   # change to a tag/branch/commit as needed

jobs:
  build-windows:
    name: Build on Windows
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-toolchain
            mingw-w64-x86_64-pkg-config
            make
            git
            autoconf
            automake
            binutils
            gcc

      - name: Clone tinycc
        shell: msys2 {0}
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Windows, MSYS2/MinGW)
        shell: msys2 {0}
        run: |
          cd tinycc
          # try configure if present
          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          # Common Windows approaches:
          # Try make target for DLL first; if not present try manual tcc invocation
          if make -n libtcc.dll 2>/dev/null; then
            make -j$(nproc) libtcc.dll || (echo "make libtcc.dll failed"; exit 1)
            cp -v libtcc.dll "${{ github.workspace }}/libtcc-windows.dll"
          else
            # fallback: build with tcc itself (many windows builds use a tcc invocation)
            # compile with -shared to create libtcc.dll (adjust as needed for your repo)
            make -j$(nproc) || true
            # If a DLL appears in bin/ or lib/ copy it out
            find . -type f -name "libtcc*.dll" -print -exec cp -v {} "${{ github.workspace }}/" \; || true
          fi

      - name: Upload Windows artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-windows
          path: |
            libtcc-windows.dll
            libtcc*.dll
            tinycc/bin/*dll
            tinycc/lib/*dll

  build-linux:
    name: Build on Linux
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install build deps (Ubuntu)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y build-essential git autoconf automake bison flex pkg-config python3 curl

      - name: Clone tinycc
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Linux)
        run: |
          cd tinycc
          # Configure if present
          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          # Build shared library first (PIC)
          # Many TCC forks expect: make libtcc.so
          if make -n libtcc.so 2>/dev/null; then
            make -j$(nproc) libtcc.so
            # copy to workspace
            cp -v libtcc.so "${{ github.workspace }}/libtcc-linux.so"
          else
            # fallback: try generic build then locate produced .so
            make -j$(nproc) || true
            find . -type f -name "libtcc*.so*" -print -exec cp -v {} "${{ github.workspace }}/" \; || true
          fi

          # Optionally run sudo make install if you want it installed system-wide
          # sudo make install

      - name: Verify shared lib
        run: |
          ls -la "${{ github.workspace }}" || true
          file "${{ github.workspace }}/libtcc-linux.so" || true

      - name: Upload Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-linux
          path: |
            libtcc-linux.so
            libtcc*.so*
            tinycc/lib/*so*

  build-alpine:
    name: Build on Alpine Linux
    runs-on: ubuntu-latest
    container:
      image: alpine:3.20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install build deps (Alpine)
        run: |
          apk update
          apk add --no-cache build-base git autoconf automake bison flex pkgconfig bash linux-headers

      - name: Clone tinycc
        run: |
          git clone --depth 1 --branch "${{ env.TCC_REF }}" "${{ env.TCC_REPO }}" tinycc
          cd tinycc
          pwd
          ls -la

      - name: Build libtcc (Alpine)
        run: |
          cd tinycc
          if [ -f ./configure ]; then
            ./configure --prefix=/usr/local
          fi

          # Many builds require building libtcc.so first (PIC)
          if make -n libtcc.so 2>/dev/null; then
            make -j$(nproc) libtcc.so
            cp -v libtcc.so "${{ github.workspace }}/libtcc-alpine.so"
          else
            make -j$(nproc) || true
            find . -type f -name "libtcc*.so*" -print -exec cp -v {} "${{ github.workspace }}/" \; || true
          fi

      - name: Upload Alpine artifact
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-alpine
          path: |
            libtcc-alpine.so
            libtcc*.so*
            tinycc/lib/*so*