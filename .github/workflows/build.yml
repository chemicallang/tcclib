name: Build libtcc (shared) artifacts

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: build-tcc-${{ github.ref }}
  cancel-in-progress: true

# Matrix: explicit includes so each row can pick runner + toolchain + arch precisely.
jobs:
  build:
    name: Build on ${{ matrix.os_name }} / ${{ matrix.toolchain }} / ${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows MSVC - 64-bit native
          - os_name: windows-msvc
            runner: windows-latest
            toolchain: msvc
            arch: x64
            short: win-msvc-x64

          # Windows MinGW - 64-bit native (uses MSYS2)
          - os_name: windows-mingw
            runner: windows-latest
            toolchain: mingw
            arch: x64
            short: win-mingw-x64

          # Linux native x86_64
          - os_name: linux
            runner: ubuntu-latest
            toolchain: gcc
            arch: x86_64
            short: linux-x86_64

          # Linux native aarch64 (if runner available or cross-compile)
          - os_name: linux
            runner: ubuntu-latest
            toolchain: gcc
            arch: aarch64
            short: linux-aarch64

          # Linux riscv64 â€” attempt (likely requires cross toolchain; may fail until you add cross toolchain).
          - os_name: linux
            runner: ubuntu-latest
            toolchain: gcc
            arch: riscv64
            short: linux-riscv64

          # macOS x86_64
          - os_name: macos
            runner: macos-latest
            toolchain: gcc
            arch: x86_64
            short: macos-x86_64

          # macOS arm64 (Apple Silicon)
          - os_name: macos
            runner: macos-latest
            toolchain: gcc
            arch: aarch64
            short: macos-aarch64

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Print build matrix info
        run: |
          echo "OS: ${{ matrix.os_name }}"
          echo "Runner: ${{ matrix.runner }}"
          echo "Toolchain: ${{ matrix.toolchain }}"
          echo "Arch: ${{ matrix.arch }}"

      # ---------- Windows MSVC path ----------
      - name: Set up Visual Studio Developer Command Prompt (MSVC)
        if: matrix.toolchain == 'msvc'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.arch }}
          # accept default vs version; set 'vs-version' if you want specific VS

      - name: Build (MSVC) - run build-tcc.bat
        if: matrix.toolchain == 'msvc'
        shell: cmd
        run: |
          cd win32
          rem ensure 64-bit target (build-tcc.bat accepts -t 64)
          build-tcc.bat -i tccdir -t 64

      - name: Create libtcc.lib from .def (MSVC)
        if: matrix.toolchain == 'msvc'
        shell: cmd
        run: |
          cd win32\tccdir
          if exist libtcc\libtcc.def (
            echo "Generating libtcc.lib from libtcc\libtcc.def"
            rem lib.exe is available in the VS dev environment
            lib /DEF:libtcc\libtcc.def /OUT:libtcc.lib || (echo "lib.exe failed" & exit /b 1)
          ) else (
            echo "No libtcc.def found at expected path: win32\tccdir\libtcc\libtcc.def"
            exit /b 1
          )

      - name: Package Windows artifact (MSVC)
        if: matrix.toolchain == 'msvc'
        shell: powershell
        run: |
          $out="artifact-${{ matrix.short }}.zip"
          Remove-Item -Force -Recurse package 2>$null || $null
          New-Item -ItemType Directory -Path package | Out-Null
          Copy-Item -Recurse -Path win32\tccdir\include -Destination package\include
          Copy-Item -Recurse -Path win32\tccdir\lib -Destination package\lib
          Copy-Item -Path win32\tccdir\libtcc.dll -Destination package\libtcc.dll
          Copy-Item -Path win32\tccdir\libtcc.lib -Destination package\libtcc.lib
          if (Test-Path "win32\tccdir\libtcc\libtcc.def") { Copy-Item "win32\tccdir\libtcc\libtcc.def" -Destination package\libtcc.def }
          if (Test-Path "win32\tccdir\tcc.exe") { Copy-Item "win32\tccdir\tcc.exe" -Destination package\tcc.exe }
          Compress-Archive -Path package\* -DestinationPath $out -Force
          Write-Output "artifact-path=$out" | Out-File -FilePath $GITHUB_OUTPUT -Encoding utf8

      # ---------- Windows MinGW path ----------
      - name: Setup MSYS2 (MinGW) on Windows
        if: matrix.toolchain == 'mingw'
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: mingw-w64-x86_64-gcc make

      - name: Build (MinGW) - run build-tcc.bat in MSYS2
        if: matrix.toolchain == 'mingw'
        shell: bash
        env:
          MSYS2_PATH_TYPE: inherit
        run: |
          cd win32
          ./build-tcc.bat -i tccdir
          # Packaging path: win32/tccdir similar to MSVC; ensure files exist
          if [ ! -f "tccdir/libtcc.dll" ]; then
            echo "ERROR: libtcc.dll not found after MinGW build"
            ls -la
            exit 1
          fi

      - name: Package Windows artifact (MinGW)
        if: matrix.toolchain == 'mingw'
        shell: powershell
        run: |
          $out="artifact-${{ matrix.short }}.zip"
          Remove-Item -Force -Recurse package 2>$null || $null
          New-Item -ItemType Directory -Path package | Out-Null
          Copy-Item -Recurse -Path win32\tccdir\include -Destination package\include
          Copy-Item -Recurse -Path win32\tccdir\lib -Destination package\lib
          Copy-Item -Path win32\tccdir\libtcc.dll -Destination package\libtcc.dll
          if (Test-Path "win32\tccdir\tcc.exe") { Copy-Item "win32\tccdir\tcc.exe" -Destination package\tcc.exe }
          if (Test-Path "win32\tccdir\libtcc\libtcc.def") { Copy-Item "win32\tccdir\libtcc\libtcc.def" -Destination package\libtcc.def }
          Compress-Archive -Path package\* -DestinationPath $out -Force
          Write-Output "artifact-path=$out" | Out-File -FilePath $GITHUB_OUTPUT -Encoding utf8

      # ---------- POSIX builds: Linux / macOS ----------
      - name: Install build prerequisites (Linux/macOS)
        if: matrix.toolchain == 'gcc' && runner.os != 'Windows'
        run: |
          if [ "$(uname -s)" = "Linux" ]; then
            sudo apt-get update
            sudo apt-get install -y build-essential autoconf automake libtool pkg-config
          elif [ "$(uname -s)" = "Darwin" ]; then
            # On macOS we assume tools are present (Xcode). Optionally install via brew.
            echo "macOS runner - assuming Xcode tools are available"
          fi

      - name: Configure & build (POSIX)
        if: matrix.toolchain == 'gcc' && runner.os != 'Windows'
        run: |
          # Build into a staging prefix so layout is consistent
          STAGING="$PWD/staging"
          mkdir -p "$STAGING"
          ./configure --disable-static --prefix="$STAGING"
          make -j$(nproc || sysctl -n hw.ncpu || echo 2)
          make install

      - name: Assemble artifact (POSIX)
        if: matrix.toolchain == 'gcc' && runner.os != 'Windows'
        run: |
          OUTDIR="$PWD/package"
          rm -rf "$OUTDIR"
          mkdir -p "$OUTDIR"
          # TinyCC installs headers under $prefix/lib/tcc/include (observed)
          if [ -d staging/lib/tcc/include ]; then
            cp -a staging/lib/tcc/include "$OUTDIR/include"
          elif [ -d staging/include ]; then
            cp -a staging/include "$OUTDIR/include"
          fi
          # lib runtime objects are usually in staging/lib/tcc
          if [ -d staging/lib/tcc ]; then
            mkdir -p "$OUTDIR/lib"
            cp -a staging/lib/tcc/* "$OUTDIR/lib/" || true
          fi
          # copy shared library (libtcc.*)
          if [ -f staging/lib/libtcc.so ]; then
            cp staging/lib/libtcc.so "$OUTDIR/libtcc.so"
          elif [ -f staging/lib/libtcc.dylib ]; then
            cp staging/lib/libtcc.dylib "$OUTDIR/libtcc.dylib"
          fi
          # copy static archive if present
          if [ -f staging/lib/libtcc.a ]; then
            cp staging/lib/libtcc.a "$OUTDIR/libtcc.a"
          fi
          # copy tcc binary if present
          if [ -f staging/bin/tcc ]; then
            cp staging/bin/tcc "$OUTDIR/tcc"
          fi
          # zip artifact
          ART="artifact-${{ matrix.short }}.zip"
          (cd "$OUTDIR" && zip -r "../$ART" .)
          echo "artifact-path=$PWD/$ART" >> $GITHUB_OUTPUT

      # ---------- Final: upload artifact ----------
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: libtcc-${{ matrix.short }}
          path: artifact-${{ matrix.short }}.zip